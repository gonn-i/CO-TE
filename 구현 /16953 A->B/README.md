[문제링크](https://www.acmicpc.net/problem/16953)

## 접근 방향 설명

> A -> B 를 도달하는 방법보다는 그 반대의 경우를 생각하는게 편한 접근인거 같다. 
> 후자의 경우, `2로 나누거나`, `가장 마지막 자리수인 1을 빼는 경우`를 생각할 수 있기 때문에 전자의 경우보다 경우의 수가 훨씬 줄어든다.
> 알고리즘의 경우, 그리디..? 라고 따져볼 수도 있갰지만 간단한 경우의 구현이라고 판단했다.

> 문제풀이  
> 1) 뒷자리가 1로 끝나는 경우는, 절대 짝수가 될 수 없기 때문에 두 경우를 `if` `else`로 나눠서 생각했다.
> 2) 두 조건문을 `B !== A` 이면서 `A <= B` 한 경우에 계속 판별하게 했는데 그 이유는 
 >2-1) 우선 `while` 첫번째 조건의 경우, 실질적인 ans (연산 횟수 +1 ) 이 도출되는 경우이며,
 >2-2) 두번째 조건의 경우, A->B가 성립될 수 없어, -1 이 출력되는 경우이기 때문이다.
> 3) 아무튼 `while` 문을 탈출하게 되면 삼항연산자를 통해서, 상황에 맞는 ans를 출력하고자 했다.
--- 

## 풀이 코드 해석
``` java script
let fs = require('fs');
let filePath = process.platform === 'linux' ? '/dev/stdin' : '/input.txt';
let input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .trim()
  .split(' ');

let [A, B] = input.map(Number);
let ans = 1;

while (B !== A && A <= B) {
  let splitedB = B.toString().split('');

  if (splitedB[splitedB.length - 1] == 1) { // 1을 빼는 겨우
    splitedB.pop();
    B = Number(splitedB.join(''));
    ans++;
  } else { // 2를 나누는 경우
    B /= 2;
    ans++;
  }
}

console.log(A == B ? ans : -1);
```
---

## 풀이 과정에서 새롭게 느낀점(배운점)

이번 문제는 무난했던 만큼, 딱히 느낀점은 없다. 이제 앞으로 코테 성실히 풀어서 골3으로 넘어가고 싶다..!!!

----

## 문제
정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.

2를 곱한다.
1을 수의 가장 오른쪽에 추가한다. 
A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

## 입력
첫째 줄에 A, B (1 ≤ A < B ≤ 109)가 주어진다.

## 출력
A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.

## 예제 입력 1 
2 162

## 예제 출력 1 
5